

1. 속도의 차이?

int Arr[100] = {0, };
위의 배열에서 *(Arr + Index) 로 접근하는 것이 Arr[Index] 보다 속도가 빠르다는 말이 있어서 직접 실험해봤다.

차이 쥐똥만큼도 안난다.
심지어 Arr[Index]이 더 빠를 때도 있다.

즉, 속도의 차이? 그냥 없다고 보는게 맞는 것 같다.

------------------------------------------------------------------------------------------

2. sizeof 연산자 결과값의 차이

sizeof(배열)을 하면 (원소의 자료형의 크기 * 원소의 개수) 만큼의 값이 나온다.
sizeof(포인터)를 하면 고정적으로 8이 나온다. 포인터는 어떤 값을 가지든 항상 8바이트로 고정되어있다.

------------------------------------------------------------------------------------------

3. 문자열 저장 방식의 차이

char Arr[100] = "Hello World";
이와 같이 초기화를 하게 되면 문자열의 끝에는 \n이 저장되며 원하는 떄에 문자열을 수정할 수 있다.
또한 문자열은 배열 안에 담겨있기 떄문에 스택메모리(동적으로 할당했다면 힙 메모리)에 저장되게 된다.

Char* StringPtr = "Hello World";
이와 같이 초기화를 하면, 포인터 변수는 스택(Or 힙)에 저장되지만 문자열은 데이터 영역에 저장된다.
리터럴 문자열은 읽기 전용으로 지정되기 때문에 런타임에서 수정할 수가 없다.

이렇게 리터럴 문자열을 따로 분류하는 이유는 메모리를 효율적으로 사용하기 위함이다.
리터럴 문자열이 사용될 때마다 매번 할당하는 것이 아니라, 데이터 영역에 할당해 놓은 뒤 동일한 문자열을 사용할 때엔
데이터 영역의 문자열의 포인터를 이용하여 추가적인 메모리 할당 없이 사용할 수 있도록 한다.
이처럼 동일한 문자열을 여러군데에서 참조하기 때문에 읽기전용으로 되어 있고 런타임에서 수정하는 것을 막고 있다고 한다.

------------------------------------------------------------------------------------------

4. 주소값 대입 가능 여부

int Arr1[10] = {0, };
int Arr2[10] = {0, };
int* Ptr = Arr1;

이 경우, Ptr = Arr2; 는 가능하지만
Arr2 = Ptr; Arr2 = Arr1; 등의 대입연산은 불가능하다.

즉, 배열의 경우엔 한 번 선언되면 그 주소값이 고정되어 바꿀 수 없게 된다.

------------------------------------------------------------------------------------------

5. 증감연산 사용 여부

이는 4번 항목과 연계되는 내용이다.

int Arr[10] = {0, };
int* Ptr = Arr1;

Ptr++; Ptr--; Ptr += 1; 등의 연산은 가능하지만
Arr++; Arr--; Arr += 1; 의 연산은 불가능하다.

이유는 4번 항목에서 말한 것과 같이 주소값이 고정되어 바꿀 수 없기 때문이다.