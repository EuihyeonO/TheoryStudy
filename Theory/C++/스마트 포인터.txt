

스마트 포인터는 malloc/free , new/delete 의 단점을 보완하기 위해 만들어진 클래스이다.

일반적인 동적할당의 경우, 메모리를 항당해주었다면 반드시 메모리를 해제해주어야 한다.
그렇지 않다면 메모리 누수가 발생할 수 있기 때문이다.

또한, 메모리의 해제와 함께 변수에 저장된 주소를 nullptr을 대입해주어야 한다.
해제된 메모리 구역을 가리키는 댕글링 포인터 문제도 발생할 수 있기 때문이다.

이러한 번거로움 때문에, 동적할당은 여러모로 불편한 존재가 되었지만 효율적인 메모리 관리를 위해서 반드시 사용해야 하는 문법이다.
그렇기 때문에, 위의 단점을 개선하여 만들어진 것이 스마트 포인터이다.

스마트 포인터는 직접 free/delete (메모리 해제)를 하지 않아도, 자동으로 해제가 된다.

원리는 이렇다.
스마트 포인터가 특정 메모리 구역을 가리키게 된다면, 객체 내부에 소유하고 있는 레퍼런스 카운트를 1씩 올리게 된다.
다른 포인터 변수가 해당 구역을 참조할 때마다 레퍼런스 카운트를 1씩 계속 올리며, 참조가 끊기게 되면 1씩 낮아지게 된다.
최종적으로 레퍼런스 카운트가 0이 되는 순간 메모리는 해제가 된다.

이 과정에서 얻게되는 이점은 두 가지이다.

1. 직접 메모리 해제를 해 줄 필요가 없다는 것.
2. 참조를 끊는 과정에서 nullptr을 사용하거나 변수가 소멸하기 때문에, 댕글링 포인터 문제를 해결할 수 있게 된다.

다만, 단점 또한 있다.

1. 함수의 호출로 정확하게 메모리를 해제하는 것이 아니라, 참조 카운트를 이용하기 때문에
원하는 시점에 메모리를 해제하는 것이 다소 번거로울 수 있다.
(모든 참조를 끊었다고 생각했으나, 예상치 못한 곳에서 해당 메모리 구역을 참조하고 있을 수도 있다.)

2. 기본적으로 스마트 포인터는 참조 카운트를 이용하기 때문에, 프로세스가 종료되고 나면 모든 참조가 해제되기 때문에 메모리 누수가 탐지되지 않는다. 
(전역 변수 등 해제 시기가 일정하지 않은 메모리는 누수가 남기도 한다.) 이러한 문제 때문에 런타임에서 발생하는 누수를 탐지하기가 어렵다. 

3. 순환 참조가 발생할 수 있다.
두 스마트 포인터가 서로를 가리키게 되면, 순환 참조가 발생할 수 있다.

4. *에 비해 사용이 불편하다.

이처럼, 스마트 포인터는 기존 동적 할당의 불편함과 문제점을 해결해 주지만,
새로운 불편함을 추가적으로 얻게 된다.
다만, 프로그램의 안정성을 확보할 수 있기 때문에 매우 유용하게 쓰인다.


스마트 포인터는 3가지 종류가 있다.

1. shared_ptr
2. weak_ptr
3. unique_ptr

shared_ptr은 기본적인 스마트 포인터 타입이다.
하나의 메모리 영역을 여러 변수가 참조할 때, 사용하는 타입이다.

weak_ptr은 상술했던 순환참조의 문제를 해결하기 위해 존재하는 스마트 포인터 타입니다.
shared_ptr로 메모리를 참조하면 strong ref count가 증가하게 된다.
반면, weak_ptr 은 weak ref count가 증가하게 되는데, weak ref count는 1이상의 값이어도 strong reg count가 0이면
메모리를 해제하게 된다. 순환 참조의 위험이 있을 경우 사용하면 된다. (람다 함수에서 스마트 포인터를 사용할 때에도 weak_ptr을 사용해야 한다.)

unique_ptr은 특정 메모리 구역을 단 하나의 변수만 참조하게 하고 싶을 때 사용한다.