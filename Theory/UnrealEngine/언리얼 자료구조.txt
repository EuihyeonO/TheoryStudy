
자료구조별 시간복잡도


			접근		검색		삽입		삭제		
TArray		O(1)	O(n)	O(n)	O(n)	<< 가장 간편하고 메모리 효율이 좋다. (중간에 슬랙이 안생김)
TSet		O(1)	O(1)	O(1)	O(1)	
TMap		O(1)	O(1)	O(1)	O(1)
TMultiMap	O(1)	O(1)	O(1)	O(1)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


TArray

Resize() -> SetNum()

IsValidIndex 를 통해 배열범위체크 가능

Ex) if(Array.isValidIndex(i) == true && Array[i].isValidIndex(j) == true)
	{
		//BFS
	}
	//이차원배열에서 {-1, 0, 1, 0}으로 BFS돌릴 때 범위검사


Heapify함수를 통해 힙으로 변환가능

템플릿 인자로 언리얼 오브젝트를 사용할 때엔 UPROPERTY()는 선택이 아닌 필수다.
(메모리 관리 문제때문에)

TArray<int32> 

UPROPERTY()
TArray<TOobjectPTR<UObject>> << 이러면 해줘야한다.
구조체의 경우엔 안써도 된다. (언리얼 오브젝트가 아니라서 어차피 엔진이 관리하는게 아님)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TSet

1. std::set과 차이.

얘는 자동정렬이 안됩니다.
정렬을 하고싶으면 sort멤버함수 호출해라.

std::set 은 이진트리 기반이지만, TSet은 동적배열 기반이다.
TSet은 해시테이블 형태로 작동하기 때문에 Unordered_Set과 유사하지만, 배열형태의 높은 캐시적중률로 인해 더욱 빠른 속력을 지님
또한 데이터가 삭제되어도 재구축이 일어나지 않음. -> std::set은 자동 정렬이지만, TSet은 정렬되지 않고 중복검사만을 진행(다만, 멤버함수 sort()를 이용해 필요에 따라 정렬하는건 가능)
다만, 데이터가 삭제되었을 때 배열에 비어있는 공간이 생길 수 있다.

또한, 해쉬 기반인만큼 구조체, 클래스 등을 템플릿 인자로 넣게 된다면, GetTypeHash() 함수를 오버로딩 해야한다.
언리얼 내부 클래스는 대부분 GetTypeHash()를 포함하고 있지만, 직접 만드는 구조체, 클래스 등은 직접 이 함수를 설계하여야 함.

std::set는 자동정렬이 되지만, TSet은 정렬이 되지 않기때문에 중복되는 값을 허용하지 않는 자료구조라는 것이 핵심 기능이다.
비교와 삭제가 TArray 보다 빠르기 때문에, 목적에 맞게 사용하면 추가적인 최적화를 노릴 수 있다.

2. 사용법

TSet<TypeName> 로 선언하여 사용.

일반적인 자료구조처럼 Add, Emplace 로 데이터 삽입
삭제는 remove로.


Array함수를 사용하면 내부에 있는 데이터와 동일한 값을 동일한 순서의 배열(TArray)형태로 반환해줌. (레퍼런스, 포인터가 아니라 복사본의 값형)

Remove()의 인자에 해당 데이터(키)를 넣어 삭제할 수 있지만, 인덱스를 넣어서도 삭제가 가능하다.(배열의 인덱스)
다만, 정확한 내부동작원리를 알아야 하고 런타임에서 해당 자료구조가 자주 바뀌게 되면 원소가 정확히 어느 인덱스에 있는지 예측이 힘들기 때문에 권장하지 않는다.

3. 특징

원소를 remove하여 슬랙이 발생한 뒤, 다시 데이터를 집어넣게 되면
앞의 슬랙부터 데이터가 채워지는게 아니라 뒤의 슬랙부터 데이터가 채워짐

1 2 3 4 에서 2, 4를 제거하여, 1 S 3 S 가 된 뒤, 다시 2, 4를 삽입하면 1 4 3 2 가됨.
(이유는? 찾아봐야겠다)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TMap

TSet과 매커니즘이 모두 동일하다.
차이점은 키, 밸류 구성으로 데이터가 튜플로 관리됨.

중복이 허용되지 않으나, 중복을 원한다면 TMultiMap을 사용하면 된다.

std::map은 인덱스접근을 할 때, 해당 키값이 존재하지 않으면
키값을 생성해서 데이터를 넣어주었다. 
-> Map[3] = 5; 를 실행하면 Map에 {3, 5}가 알아서 삽입되는데, 
TMap은 이런거 안되지만 동일한 기능을 함수로는 제공하고 있다.
TMap.FindOrAdd(3, 5)를 하면, 내부에 값이 있다면 반환하고 없다면 생성해서 반환한다.

