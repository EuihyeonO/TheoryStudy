
언리얼 엔진은 가비지 컬렉터 기능을 제공하고 있다.

가비지 컬렉션 작동 방식 :

스마트포인터와 유사하게 레퍼런스 카운트를 기반으로 한다.
루트 셋 오브젝트가 있고, NewObject로 생성된 객체는 트리 구조로 연결된다. (CreateComponent 등 내부적으로 다 NewObjectPtr로 만든다는 거)
객체의 레퍼런스 카운트가 0이되는 순간 트리에서 연결이 끊긴다.
가비지 컬렉션은 작동 주기가 있는데, 디폴트는 61초.
61초마다 한 번씩 루트 노드부터 순회하여 참조되지 않은 객체(연결이 끊겨있는 객체)들을 매모리 해제한다.

즉, 프로그래머가 메모리 해제를 원하는 시점에 할 수 있는 것이 아니라
참조만 끊어놓으면 가비지 컬렉터가 동작할 때 해제된다.
Destroy함수도 이와 같이 참조만 끊어놓을 뿐 실제로 메모리 해제를 하진 않는다.

중요한 점 :
프로그래머가 해제를 지시한다고 바로 메모리 해제를 하는게 아니라
예약만 해놓고, 주기가 돌아오면 한 번에 처리한다는거.
우리가 생각하는 것과 실제 가비지 콜렉터가 작동하는 시기가 다르다는 것을 인지하고 프로그래밍을 해야
더욱 안정적으로 설계할 수 있기 때문에, 이 점을 반드시 인지해야 한다.

중요한점 2 :
UObject의 포인터는 자동으로 가비지 컬렉터의 대상이 되는데,
이를 위해서는 클래스를 루트 셋 오브젝트가 참조를 할 수 있어야 한다.
그런데, UPROPERTY() 매크로를 선언하지 않은 멤버함수는 루트 셋 오브젝트가 참조할 수 없다.

즉, 가비지 컬렉터가 처음으로 작동하는 시기에 바로 인스턴스가 해제되어 버린다!!!

그렇기 때문에, 언리얼 오브젝트의 포인터 변수는 무조건 UPROPERTY()를 선언해야 한다.

중요한 점 3 :
가비지 컬렉터가 메모리를 회수하고 나면, 해당 메모리 주소를 참조하고 있던 변수는
자동으로 nullptr로 초기화를 해준다.
즉 포인터가 유효한지 아닌지를 검사하려면 널포인터인지만 조회하면 뒨다는거...
가비지 컬렉터를 제대로 설정했다면 유효하지 않은 주소를 참조하고 있는 포인터 변수는 있을 수 없다. (댕글링 포인터, 와일드 포인터 등..)

중요한 점 4 :
UObject를 상속받지 않고 C++ 방식으로 선언된 구조체, 클래스 등은 가비지 콜렉터 대상이 아니니까
메모리 관리에 신경을 쓰자. 할당, 해제 짝을 지어서 반드시 해제를 해주어야 한다.



