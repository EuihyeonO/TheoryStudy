
push_back() -> Add()
emplace_back() -> Emplace()

: 모든 경우에서 Emplace가 속도가 빠르지만, 가독성 측면에서는 Add가 좋기 때문에
자료형이 단순한 경우에는 Add를 사용하고 복잡한 경우에는 Emplace를 사용하는 것을 권장

size() -> Num()
erase() -> remove()

Contains() : 특정 원소가 존재하는가 없는가에 대한 bool값을 반환하는 함수
Find() : 존재한다면 그 값을 반환하고 없다면 nullptr 반환
-> 내부 데이터가 포인터가 아닌 값형이더라도 int* 와 같은 포인터형으로 반환함.


STL과 동일하게 reserve()를 이용해 메모리를 미리 할당하는 것이 가능한데, 이 때 원소가 들어가있지 않고 할당만 되어있는 여유 메모리를 슬랙(Slack)이라고 함.
Ex) Capacity가 10이고 size가 7이라면, 3 * sizeof(자료형) 만큼의 메모리가 Slack.

이 슬랙을 제거하고 싶다면, Shrink함수를 사용하면 된다. But 중간에 있는 슬랙은 제거되지 않는다.
(예를 들어, TSet같은 경우엔 데이터를 삭제해도 정렬이 되지 않기때문에 삭제된 공간이 슬랙이 되는데 이건 제거되지 않고, 끝쪽에 있는 슬랙만 제거됨)

슬랙을 완전히 제거하고 싶다면, Compact(), CompactStable()을 이용하면 됨.
이 함수는 데이터를 앞으로 몰아넣고 빈 공간(슬랙)을 모두 뒤쪽으로 옮김.
이후 shrink()를 사용하면 모든 슬랙이 사라지게 됨.
Compact()와 CompactStable()의 차이는 앞으로 데이터를 압축하는 과정에서 기존의 순서를 유지할 것인가 말건가의 차이.
당연히 기존의 순서가 보장되지 않는 Compact()가 더 빠름.

이터레이터 생성은 CreateIterator 및 CreateConstIterator(읽기 전용)

2. 멤버함수 Sort를 이용해서 소팅가능

3. 자료구조의 인자로 언리얼 오브젝트를 사용할 때엔 UPROPERTY()는 선택이 아닌 필수다.
(메모리 관리 문제때문에)
구조체의 경우엔 안써도 된다. (언리얼 오브젝트가 아니라서 어차피 엔진이 관리하는게 아님)

